---
title: "MPN_project"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(eval = FALSE)
```

### **GETTING THE DATA OUT OF QIIME**

First thing is first, getting your OTU (ESV...exact sequence variant) table out of qiime. Its a little tricky but lets walk you through what i did to get the file: "feature-table-MPN.tsv"

```{bash}
module load enthought_python/7.3.2
export HDF5_DISABLE_VERSION_CHECK=2
unzip table.qza 
# cd into that directory, then the data folder. Should be feature-table.biom in there.
biom convert -i feature-table.biom -o feature-table.tsv --to-tsv
biom head -i feature-table.tsv
```

You have to do the same thing to get the taxonomy information:

```{bash}
unzip taxonomy.qza
# cd into that directory, then the data folder. Should be taxonomy.tsv in there.
# you can do some bash or R to merge the files. The feature IDs should be in the same order for both files.
```

All the libraries to load for this project:

```{r}
library("vegan")
library("devtools")
## devtools::install_github("GuillemSalazar/EcolUtils")
library("EcolUtils")
library(ggplot2)
library(tidyverse)
library("factoextra")
library(nlme)
library(labdsv)
library(knitr)
library(kableExtra)
library("Hmisc")
library(corrplot)
library(ggpubr)
library(ggcorrplot)
library(corrr)
library(magrittr)
```


### **RAREFACTION OF YOUR DATA**

This is an important step that basically lets you compare samples with uneven sequencing depth to each other (by evening them out!!). For your data, i rarefied to **8500** sequences.

```{r}

## Open up your OTUtable. Make sure the samples are rows and the features are columns.
## Transpose if necessary. IF its a tsv, make sure thats right too.

qiime_raw <- t(read.csv("feature-table-MPN.tsv", row.names = 1, check.names = FALSE, sep = "\t"))

## IF YOU EXPORT FROM taxa-bar-plots.qzv (like L7 or something), sometimes metadata comes along. 
## Let's clean that up.
#qiime_clean <- qiime_raw[ ,grep(pattern="^k__|Unassigned;__",colnames(qiime_raw))]

## IF YOU EXPORT USING THE BIOM CONVERT THING ABOVE, you are golden. No metadata.
qiime_clean <- qiime_raw

## Lets see how many samples were probably gonna lose...
barplot(sort(rowSums(qiime_clean)), ylim = c(0, max(rowSums(qiime_clean))), 
        xlim = c(0, NROW(qiime_clean)), col = "Blue", main = "Reads per Sample") 
as.matrix(sort(rowSums(qiime_clean)))

## Its time to dance. And by dance i mean rarify. Pick your sampling depth.
## This will make a distance matrix. You can put it in primer or whatnot.
median.avg.dist <- avgdist(qiime_clean, sample = 8500, iterations = 10, 
                           meanfun = median, dmethod = "bray")

## Also for alpha diversity! This will make a rarified OTU table. 
## In talking a lot with stephen, we think less interationg (10) is
## more appropriate in this step.

rare_perm_otu <- rrarefy.perm(qiime_clean, sample = 8500, n = 10, round.out = T)
alpha_rare <- rare_perm_otu[rowSums(rare_perm_otu) >= 8500-(8500*.1), colSums(rare_perm_otu) >= 1]

barplot(sort(rowSums(alpha_rare)), ylim = c(0, max(rowSums(rare_perm_otu))), 
        xlim = c(0,NROW(rare_perm_otu)), col = "Blue", main = "Reads after rarefaction")

## Lets make that sucker a dataframe!

bray_distance_matrix <- as.data.frame(as.matrix(median.avg.dist))

## Grand finale. Write it to a file.

write.csv(bray_distance_matrix, file = "bray_distances.csv")
write.csv(alpha_rare, file = "rarified_otu-table.csv")
```


### **ADDING TAXONOMY TO YOUR NEW, RAREFIED, OTU TABLE**

So here we link up the OTU ESV IDs with the actual taxa they are assigned through Qiime and greengenes.

```{r}
otu_with_taxa <- as.data.frame(alpha_rare)
taxonomy <- read.csv("taxonomy.tsv", sep = "\t")
names(otu_with_taxa) <- taxonomy$Taxon[match(names(otu_with_taxa), taxonomy$Feature.ID)]
NC <- NCOL(otu_with_taxa)
write.csv(otu_with_taxa, file = "rarified_otu-table.csv")
```

### **Getting your primer files**

This is for merging your metadata file with the created files above...you have to re-run some things bc not all the samples have metadata (or vice versa). 

```{r}
OTU <- read.csv("rarified_otu-table.csv", row.names = 1, check.names = F, sep = ",")
metadata <- read.csv("metadata_2.14.19.txt", check.names = F, sep = "\t")
OTU_factors <- merge(OTU, metadata, by.x = "row.names", by.y = "Sample")
OTU_withFactors <- OTU_factors[,1:NCOL(OTU)]
rownames(OTU_withFactors) <- OTU_withFactors[,1]
OTU_withFactors[,1] <- NULL
primer_bray <- avgdist(OTU_withFactors, sample = 8500, iterations = 100, meanfun = median, dmethod = "bray")

primer_bray.df <- as.data.frame(as.matrix(primer_bray))

primer_bray.df.final <- merge(primer_bray.df, metadata, by.x = "row.names", by.y = "Sample")
rownames(primer_bray.df.final) <- primer_bray.df.final[,1]
primer_bray.df.final[,1] <- NULL

#Cytokines
cytokines <- read.csv("Cytokines.txt", row.names = 1, check.names = F, sep = "\t")
cytokines_factors <- merge(cytokines, metadata, by.x = "row.names", by.y = "CYTOKINE")


write.csv(cytokines_factors, file = "PRIMER-Cytokines.csv")
write.csv(primer_bray.df.final, file = "PRIMER-Bray_factors.csv")
write.csv(OTU_withFactors, file = "PRIMER-OTU_factors.csv")
```

**So from here you could take the files and put them into Primer-e or another program**

**Or...**

**BE A BOSS AND DO MORE IN R**

Here im subsetting the data to make it more easy to do fun stuff with:

```{r}
otu_lite <- (otu_with_taxa[, order(-colMeans(otu_with_taxa))])[1:150,1:NC]
```

Next up, lets merge it with metadata!

```{r}
# !!!Make sure the sample names in the file dont have the word SAMPLE in them!!!!!
otu_meta <- merge(otu_lite, metadata, by.x = "row.names", by.y = "Sample")
rownames(otu_meta) <- otu_meta[,1]
otu_meta$Row.names <- NULL
otu_meta$Individual <- as.factor(otu_meta$Individual)
otu_lite1 <- otu_meta[,1:NC]
```


### **Doing Stats in R**

### Shannon Diveristy
Alpha Diversity, you are up first:

```{r}
cbPalette <- (c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7"))
otu_meta$Shannon <- diversity(otu_lite1, "shannon")
alpha_health <- ggplot(data = otu_meta) +
  aes(x = HealthStatus, y = Shannon, fill = HealthStatus) +
  geom_boxplot() + geom_jitter(width = 0.2) +
  labs(x = 'Health Status',
    y = 'Shannon Diversity') +
  theme_classic(base_size = 14) + scale_fill_manual(values=c("deepskyblue3", "orange")) + stat_compare_means(method = "t.test")
alpha_health
ggsave("alpha_diversity.pdf", alpha_health)
```

### PCOA
Beta Diversity, youre next. Lets try to make a pretty PCA first:

```{r}

mpn.pr <- prcomp(otu_lite1, center = T, scale = F)
summary(mpn.pr)

screeplot(mpn.pr, type = "l", npcs = 15, main = "Screeplot of the first 10 PCs")
abline(h = 1, col="red", lty=5)
legend("topright", legend=c("Eigenvalue = 1"),
       col=c("red"), lty=5, cex=0.6)

cumpro <- cumsum(mpn.pr$sdev^2 / sum(mpn.pr$sdev^2))
plot(cumpro[0:15], xlab = "PC #", ylab = "Amount of explained variance", main = "Cumulative variance plot")
abline(v = 6, col="blue", lty=5)
abline(h = 0.46453, col="blue", lty=5)
legend("topleft", legend=c("Cut-off @ PC6"),
       col=c("blue"), lty=5, cex=0.6)


Health_status_pca <- fviz_pca_ind(mpn.pr, pointshape = 21, 
             pointsize = 2, 
             fill.ind = otu_meta$HealthStatus, 
             col.ind = "black", 
             palette = "jco", 
             addEllipses = T,
             label = "var", #also if you do label = "ind", you can label the points
             repel = FALSE,
             legend.title = "Health Status") +
  ggtitle("2D PCA-plot from 30 feature dataset") +
  theme(plot.title = element_text(hjust = 0.5)) + scale_fill_manual(values=c("#56B4E9", "orange"))
Health_status_pca
ggsave("Health-PCA.pdf", Health_status_pca)
```


### nMDS
What about an nMDS??

```{r}
otu.mds <-metaMDS(otu_lite1, distance="bray", k=2)
# Stress 0.23 at k=2...gets below 0.2 if you run it at k=3
stressplot(otu.mds)

sites <- as.data.frame(scores(otu.mds, display = "sites"))
species <- as.data.frame(scores(otu.mds, display = "species"))

nmds.sites <- sites %>%
  merge(., otu_meta, by = "row.names")

nmds.plot <- ggplot() + 
  geom_point(data = nmds.sites, aes(NMDS1, NMDS2, color = HealthStatus, shape = HealthStatus), size = 4) +
  scale_shape_manual(values = c(19,15,17)) + geom_text(data = sites, aes(NMDS1, NMDS2, label = rownames(sites)), check_overlap = TRUE) +
  theme_classic() + 
  annotate("text", label = "Stress = 0.16", x = 2, y = 0.8) +
  theme(axis.title = element_text(size = 20), axis.text = element_text(size = 18), 
        legend.text = element_text(size = 20), legend.title = element_text(size = 20)) + scale_colour_manual(values=c("deepskyblue3", "orange"))
nmds.plot
ggsave("nMDS_healthStatus.pdf", nmds.plot)

```


### LME
Should we add some stats to this?? Yes. This is the bread and butter. A Permanova is not really appropriate here bc we have a TON of repeated measures. So i like Linear Mixed Effects models (LME). 

```{r}
# lets get the PC1 and PC2 from above. These are from Principal components analysis (PCA)
tmp <- predict(mpn.pr)
tmp2 <- tmp[,1:2]
otu_meta <- merge(tmp2, otu_meta, by.x = "row.names", by.y = "row.names")

# Im also just gonna add PCO, a principal coordinates analysis (PCO). These are different and you shoud just read about them.
# Im going to do the LME on the PCO1
tmp.pco <- pco(median.avg.dist, k =2)
otu_meta <- merge(as.data.frame(tmp.pco$points), otu_meta, by.x = "row.names", by.y = "row.names")
names(otu_meta)[2] <- "PCO1"
names(otu_meta)[3] <- "PCO2"

health_status.lme <- lme(PCO1 ~ HealthStatus, data = otu_meta, 
                        random = ~ 1|Individual, cor=corAR1())
summary(health_status.lme)
anova(health_status.lme) %>% kable(caption = "LME Health Status", booktabs = T) %>% kable_styling(position = "float_right", font_size = 16, latex_options = c("striped", "hold_position"))




```

### PERMANOVA
We could try a permanova on the individual:

```{r}
adonis(otu_meta[,1:NC] ~ otu_meta$STATUS, otu_meta, permutations = 999, method = "bray", by = "terms") 

# Loop through all the factors. Input is an rarefied OTU table with factors on the 
# last few columns of the OTU table. In this case, there are factors in the 
# beginning too that i have to remove. 

perm_otu <- otu_meta[,6:NCOL(otu_meta)]
meta_start <- which( colnames(perm_otu)=="HealthStatus")
counter = 2824
permanova_df <- data.frame(factor=character(), R2=integer(), p_value=integer())
for(i in colnames(otu_meta[2824:NCOL(otu_meta)])){
  factor_name <- paste(colnames(otu_meta[counter]))
  permanova_result <- adonis(otu_meta[,1:NC] ~ as.character(otu_meta[[counter]]), 
                             permutations = 999, method = "bray", by = "terms", strata = as.character(otu_meta$Individual))
  R2_value <- permanova_result$aov.tab$R2[1] * 100
  P_value <- permanova_result$aov.tab$`Pr(>F)`[1]
  permanova_df <- add_row(permanova_df, factor = factor_name, R2 = R2_value, p_value = P_value)
  counter = counter + 1
  if (counter == 2849) break
}

# DBRDA analysis to take into account random effect
tmp <-dbrda(otu_meta[,1:NC] ~ as.character(otu_meta$STATUS) + Condition(as.character(otu_meta$Individual)), otu_meta, distance = "bray")
tmp1 <- anova(tmp)

tm2 <- varpart(otu_meta[,1:NC], ~ as.character(otu_meta$STATUS), ~ as.character(otu_meta$Individual))
# Using the same pvalue correction as that IBD science paper: Bengamini Hochberg
permanova_df$p_adjust <- p.adjust(permanova_df$p_value, method = "BH")

ggplot(data = permanova_df) +
  aes(x = factor, weight = R2) +
  geom_bar(fill = '#0c4c8a') +
  labs(title = 'R2 on 16S Data',
    x = 'Measured Factor',
    y = 'Varience Explained (%)',
    subtitle = '(PERMANOVA ANALYSIS)') +
  theme_classic(base_size = 14) +
  geom_text(aes(label = sprintf("%.1f", R2), y= R2), hjust = -0.1, size = 3) +
  coord_flip()



```


### SIMPER test
Simper test to look for which species are more present in different groups (like MPN vs Healthy)

```{r}
mpn.simper <- summary(mpn.simper <- simper(otu_lite1, otu_meta$HealthStatus, permutations = 5))

# Get the top 12 bacteria that are most different from MPN and Healthy. 
# This subset grabs 13 i think
tmp <- subset(mpn.simper$MPN_HEALTHY, subset = mpn.simper$MPN_HEALTHY$cumsum < 0.233)
simper.tmp <- merge(tmp, t(otu_lite1), by.x = "row.names", by.y = "row.names")
row.names(simper.tmp) <- simper.tmp$Row.names
simper.tmp$Row.names <- NULL
simper.tmp[,1:7] <- NULL
simper.tmp <- t(simper.tmp)

```

### Correlations with most differential species (from SIMPER test) and cytokines:

```{r}
cytokines <- read.csv("Cytokines.txt", sep = "\t")
otu_meta <- merge(cytokines, otu_meta, by.x = "Sample", by.y = "Individual")

# Here were normalizing the cytokine data by col total, and getting it into the right format
cyto <- as.matrix(otu_meta[, 3:15])
cyto1 <- as.data.frame(cyto)
rownames(cyto1) <- cyto1$Row.names
cyto1$Row.names <- NULL
cyto1[] <- lapply(cyto1, function(x) as.numeric(as.character(x)))
cyto1 <- sweep(cyto1, 2, colSums(cyto1), FUN="/")

# Here were merging the taxa (from simper test) and cytokine data
# The number at the end of the function (after pattern) in [] determines the taxa level
# i.e 6 = family, 7 = genus, etc.
cor_input <- merge(cyto1, simper.tmp, by.x = "row.names", by.y = "row.names")
cor_input$Row.names <- NULL
#colnames(cor_input)[13:NCOL(cor_input)] <- sapply(colnames(cor_input)[13:NCOL(cor_input)], FUN = function(x){return(as.character(unlist(str_split(as.character(x), pattern = "__"))[7]))})

# Here were doing the correlations and making it so it just does cytokines vs taxa,
# not cytokines and taxa vs cytokines and taxa...correlations like to do an all vs
# all approach.
cor.matrix <- rcorr(as.matrix(cor_input), type="spearman")
z <- cor.matrix$r[1:12,]
a <- z[, 13:24]
p <- cor.matrix$P[1:12,]
s <- p[, 13:24] 

# Here were plotting the correlations. Only plotting correlations that are significant at p < 0.1
pdf("simper_correlations.pdf")
correlations <- corrplot(a, type = "full", order = "hclust", 
         p.mat = s, sig.level = 0.1, insig = "blank", tl.col = "black", method="circle", na.label.col = "white", title = "Bacterial Family Correlations", mar=c(0,0,4,0), outline = TRUE, hclust.method = "average", tl.cex = 0.2)
dev.off()

```

### Full_correlations

```{r}

cytokines <- read.csv("Cytokines.txt", sep = "\t")
genus_raw <- read.csv("genus.csv", row.names = 1, check.names = FALSE)
genus_clean <- genus_raw[ ,grep(pattern="^k__|Unassigned;__",colnames(genus_raw))]

colnames(genus_clean) <- sapply((strsplit(colnames(genus_clean), split = ";")), '[', 6)
genus_clean <-  genus_clean[ , -which(names(genus_clean) %in% c("__","g__"))]

rare_perm_genus <- rrarefy.perm(genus_clean, sample = 8500, n = 10, round.out = T)
genus_rare <- rare_perm_genus[rowSums(rare_perm_genus) >= 8500-(8500*.1), colSums(rare_perm_genus) >= 1]



metadata_subset <- dplyr::select(metadata, Sample, Individual, STATUS, SPOUSE, CYTOKINE, SYMPTOM, SUBSTATUS)

genus_meta <- merge(metadata_subset, genus_rare, by.x = "Sample", by.y = "row.names")
corr_genus <- merge(cytokines, genus_meta, by.x = "Sample", by.y = "Individual")
corr_genus[15] <- NULL
corr_aggarate <- corr_genus %>% group_by(Sample) %>% summarise_each(funs(mean))
corr_aggarate$Status <- NULL
corr_aggarate$STATUS <- NULL
corr_aggarate$SPOUSE <- NULL
corr_aggarate$SYMPTOM <- NULL
corr_aggarate$SUBSTATUS <- NULL

corr_aggarate_drop <- colSums(corr_aggarate == 0, na.rm=TRUE) < 10
corr_aggarate_clean <- corr_aggarate[corr_aggarate_drop]

rownames(corr_aggarate_clean) <- corr_aggarate_clean$Sample
corr_aggarate_clean$Sample <- NULL
corr_aggarate_clean$CYTOKINE <- NULL

corr_aggarate_clean %>% correlate(method = "spearman") %>% network_plot(min_cor=0.5, repel = T)
corrplot.mixed(cor(corr_aggarate_clean), order="hclust", tl.col="black")

ggcorrplot(cor(corr_aggarate_clean), p.mat = cor_pmat(corr_aggarate_clean), hc.order=TRUE, type='lower', insig='blank')

```


### **SESSION INFO**

> print(sessionInfo())
R version 3.4.4 (2018-03-15)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: macOS High Sierra 10.13.6

Matrix products: default
BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] corrplot_0.84    Hmisc_4.1-1      Formula_1.2-2    survival_2.42-3  kableExtra_1.0.1 knitr_1.20       labdsv_1.8-0    
 [8] cluster_2.0.7-1  MASS_7.3-51.1    mgcv_1.8-23      nlme_3.1-137     factoextra_1.0.5 forcats_0.3.0    stringr_1.3.0   
[15] dplyr_0.7.8      purrr_0.2.5      readr_1.1.1      tidyr_0.8.0      tibble_1.4.2     tidyverse_1.2.1  ggplot2_3.1.0   
[22] EcolUtils_0.1    devtools_1.13.5  vegan_2.5-1      lattice_0.20-38  permute_0.9-4   

loaded via a namespace (and not attached):
 [1] httr_1.3.1          jsonlite_1.5        viridisLite_0.3.0   splines_3.4.4       modelr_0.1.2        assertthat_0.2.0   
 [7] latticeExtra_0.6-28 cellranger_1.1.0    yaml_2.1.18         ggrepel_0.7.0       pillar_1.2.1        backports_1.1.2    
[13] glue_1.3.0          digest_0.6.18       checkmate_1.8.5     RColorBrewer_1.1-2  rvest_0.3.2         colorspace_1.3-2   
[19] htmltools_0.3.6     Matrix_1.2-14       plyr_1.8.4          pkgconfig_2.0.2     broom_0.5.0         haven_1.1.2        
[25] scales_1.0.0        webshot_0.5.1       htmlTable_1.11.2    withr_2.1.2         nnet_7.3-12         lazyeval_0.2.1     
[31] cli_1.0.0           magrittr_1.5        crayon_1.3.4        readxl_1.0.0        memoise_1.1.0       evaluate_0.10.1    
[37] foreign_0.8-69      xml2_1.2.0          data.table_1.11.8   tools_3.4.4         hms_0.4.2           munsell_0.5.0      
[43] bindrcpp_0.2.2      compiler_3.4.4      rlang_0.3.0.1       grid_3.4.4          rstudioapi_0.7      htmlwidgets_1.0    
[49] base64enc_0.1-3     rmarkdown_1.9       gtable_0.2.0        R6_2.3.0            gridExtra_2.3       lubridate_1.7.4    
[55] bindr_0.1.1         rprojroot_1.3-2     stringi_1.1.7       parallel_3.4.4      Rcpp_1.0.0          rpart_4.1-13   


